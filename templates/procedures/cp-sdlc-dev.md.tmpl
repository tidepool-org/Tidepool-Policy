### Software Development Process

#### Overview

Software development at {{companyShortName}} follows a release strategy that provides
traceability for production software changes. Features, enhancements, and bugs
are written up as Issues in {{ticketingSystem}}. An engineer on a small team proposes changes
necessary and creates a review for the team ({{sourceControl}}). Continuous integration
({{ciSystem}}) kicks off unit and functional tests which pass before changes are
merged into the repository. Once the review is complete, the changes are now
deployed to the development environment where regression and end-to-end tests
are run before the new code replaces the existing in-service code (test then
deploy model). Small teams can decide to follow a source-control branching
strategy that makes sense: git-flow, github flow.

{{companyShortName}} practices continuous delivery of code into production
through multiple environments: development, testing, production. The deploy
process and infrastructure roll-out are written as code (using technologies
such as Terraform and AWS Cloudformation) and managed under source control.

{{companyShortName}}’s multiple lower environments (dev, test) provide an ecosystem of
sample data sets that exercise the application and services when test automation
is run. The test environment is where the system is stressed for performance and
scalability. Performance and scalability changes are driven by metric data
captured through monitoring and logging (metrics before and after change –
typically captured as part of the issue description/writeup).

Deployments to production are gated by change control process where an issue is
opened which identify what is new/changed ({{ticketingSystem}}). Sign-offs are recorded by
development, testing, security, and product management. Production roll-outs
happen on a regular basis without impact to service. This continuous process
allows for security updates to roll out regularly and with urgency. If there is
impact to production, a rollback is performed to restore service and whatever
caused the problem is reverted from source. This restarts the re-proposal
approval process of source changes. This process keeps the set of differences
between the development environment and the production environment as low as
possible.

In the continuous delivery mindset, features are not released by the deployment
of code into production, instead features are enabled in production at the
appropriate time (dark launching). Feature toggle enablement in production is gated
by a change control ticket ({{ticketingSystem}}) that follows the software roll-out approval
process. Feature toggle enablement in production can have a few more
dependencies than code. Those dependencies include things like external
documentation, early access programs, and internal playbooks for supporting the
feature.

#### Secure Development Standards

[Traceability](https://en.wikipedia.org/wiki/Traceability) of code changes allow
for our software to be a living entity.  Our current system for documenting
changes is {{ticketingSystem}}. Every commit and/or Pull-Request, should have a {{ticketingSystem}} supplied
that describes contextually why this change is necessary and reasonable.  These
artifacts over time allow for one to trace the lineage of why our production
software and services change over time.

All {{companyShortName}} `git` repositories have a company standard configuration from a
{{sourceControl}} perspective.  This standard is a guideline and can be relaxed, but
socialize when those exceptions are needed.  One example of an exception, is the
`wiki` repository, as editing a wiki and always requiring a PR in this setting
slows down 'flow'.

-   Code: <#>

-   Repo settings: <#>

-   Build: <#>

**NOTE**: The Sandbox project (and repos) do not follow this standard.  And
certain projects might be excluded (e.g. `wiki`).

**Developers follow the branch strategy and code review process below:**

1. All development uses feature branches based on the main branch used for the
   current release. Any changes required for a new feature or defect fix are
   committed to that feature branch.

    * These changes must be covered under 1) a unit test where possible, or 2)
      integration tests.
    * Integration tests are _required_ if unit tests cannot reliably exercise
      all facets of the change.

2. Developers are strongly encouraged to follow the [commit message conventions
   suggested by GitHub](https://github.com/blog/926-shiny-new-commit-styles).

    * Commit messages should be wrapped to 72 characters.
    * Commit messages should be written in the present tense. This convention
      matches up with commit messages generated by commands like git merge and
      git revert.
    * Additionally, the commit messages should start with the {{ticketingSystem}} Issue ID when
      applicable.

3. Once the feature and corresponding tests are complete, a pull request (PR)
   will be created using the {{sourceControl}} web interface. The pull request should
   indicate which feature or defect is being addressed and should provide a
   high-level description of the changes made.

4. Code reviews are performed as part of the pull request procedure. Once a
   change is ready for review, the author(s) will notify other engineers using
   an appropriate mechanism, typically by adding reviewers as PR approvers.

    * Other engineers will review the changes, using the guidelines above.
    * Engineers should note all potential issues with the code; it is the
      responsibility of the author(s) to address those issues or explain why
      they are not applicable.
    * If changes/commits are made to a PR, it should reset previous approvals
      and require review and approvals again before the PR can be merged.
    * Once the review process finishes, each reviewer should approve the PR, at
      which point the original author(s) may merge their change into the main
      branch (i.e. master).
    * PR can only be merged with at least one approval from a reviewer other
      than the author.

5. If the feature or defect interacts with sensitive data, or controls access to
   sensitive data, or contains security/risky infrastructure
   changes to the target environment, the code changes must be reviewed by the
   Security team before the feature is marked as complete.

    * This review must include a security analysis for potential vulnerabilities
      such as those listed in the [OWASP Top
      10](https://www.owasp.org/index.php/Top10).
    * This review must also verify that any actions performed by authenticated
      users will generate appropriate audit log entries.

#### Release Strategy

Features, enhancements, and bugs are written up as issues ({{ticketingSystem}}).  An engineer
on a small team proposes changes necessary and creates a review for the team
({{sourceControl}}).  Continuous integration ({{ciSystem}}) kicks off unit and functional
tests which pass before changes are merged into the repository.  Once the review
is complete, the changes are now deployed to the development environment where
regression and end-to-end tests are run before the new code replaces the
existing in-service code (test then deploy model). Small teams can decide to
follow a source-control branching strategy that makes sense: git-flow, github
flow.

{{companyShortName}} practices continuous delivery of code into production through multiple
environments: development, testing, production. The deploy process and
infrastructure roll-out are written as code (Terraform) and managed under source
control.

{{companyShortName}}'s multiple lower environments (dev, test) provide an ecosystem of
sample data sets that can be used to exercise the application and services when
test automation is run.  The test environment is where the system is stressed
for performance and scalability.  Performance and scalability changes are driven
by metric data captured through monitoring and logging (metrics before and after
change - typically captured as part of the issue description/writeup).

Deployments to production are gated by change management process where an issue
is opened which identify what is new/changed ({{ticketingSystem}}).  Sign-offs are recorded by
development, testing, security, and product management.  Production roll-outs
happen on a regular basis without impact to service.  This continuous process
allows for security updates to roll out regularly and with urgency.  If there is
impact to production, a rollback is performed to restore service and whatever
caused the problem is reverted from source.  This restarts the re-proposal
approval process of source changes.

This process keeps set of differences between the development environment and
the production environment as low as possible.

Features may be released via code deployments or features may be enabled in
production at an appropriate time (dark launching).  Feature toggle enablement in
production is gated by the same change management ticket ({{ticketingSystem}}) that follows the
software roll-out approval process.  Feature toggle enablement in production can
have a few more dependencies than code.  Those dependencies include things like
external documentation, early access programs, and internal playbooks for
supporting the feature.

**Detailed process and procedures for code promotion and production release:**
See [Configuration and Change Management](ccm.md).
